import { g as vn, w as gn, c as L } from "../core-469ea631.js";
import { Z as bn, b as Pn, d as Cn, p as Tn, s as An } from "../core-469ea631.js";
var gt = (() => {
  var N = import.meta.url;
  return function(q = {}) {
    var s = typeof q < "u" ? q : {}, ae, Z;
    s.ready = new Promise((e, t) => {
      ae = e, Z = t;
    });
    var oe = Object.assign({}, s), se = typeof window == "object", ue = typeof importScripts == "function";
    typeof process == "object" && typeof process.versions == "object" && process.versions.node;
    var F = "";
    function yt(e) {
      return s.locateFile ? s.locateFile(e, F) : F + e;
    }
    var Pe;
    (se || ue) && (ue ? F = self.location.href : typeof document < "u" && document.currentScript && (F = document.currentScript.src), N && (F = N), F.indexOf("blob:") !== 0 ? F = F.substr(0, F.replace(/[?#].*/, "").lastIndexOf("/") + 1) : F = "", ue && (Pe = (e) => {
      var t = new XMLHttpRequest();
      return t.open("GET", e, !1), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response);
    })), s.print || console.log.bind(console);
    var G = s.printErr || console.error.bind(console);
    Object.assign(s, oe), oe = null, s.arguments && s.arguments, s.thisProgram && s.thisProgram, s.quit && s.quit;
    var K;
    s.wasmBinary && (K = s.wasmBinary), s.noExitRuntime, typeof WebAssembly != "object" && J("no native wasm support detected");
    var fe, Ue = !1, I, C, X, ce, j, g, We, Ie;
    function je() {
      var e = fe.buffer;
      s.HEAP8 = I = new Int8Array(e), s.HEAP16 = X = new Int16Array(e), s.HEAP32 = j = new Int32Array(e), s.HEAPU8 = C = new Uint8Array(e), s.HEAPU16 = ce = new Uint16Array(e), s.HEAPU32 = g = new Uint32Array(e), s.HEAPF32 = We = new Float32Array(e), s.HEAPF64 = Ie = new Float64Array(e);
    }
    var He, xe = [], Me = [], Ve = [];
    function _t() {
      if (s.preRun)
        for (typeof s.preRun == "function" && (s.preRun = [s.preRun]); s.preRun.length; )
          wt(s.preRun.shift());
      Ce(xe);
    }
    function mt() {
      Ce(Me);
    }
    function $t() {
      if (s.postRun)
        for (typeof s.postRun == "function" && (s.postRun = [s.postRun]); s.postRun.length; )
          Pt(s.postRun.shift());
      Ce(Ve);
    }
    function wt(e) {
      xe.unshift(e);
    }
    function bt(e) {
      Me.unshift(e);
    }
    function Pt(e) {
      Ve.unshift(e);
    }
    var H = 0, Q = null;
    function Ct(e) {
      H++, s.monitorRunDependencies && s.monitorRunDependencies(H);
    }
    function Tt(e) {
      if (H--, s.monitorRunDependencies && s.monitorRunDependencies(H), H == 0 && Q) {
        var t = Q;
        Q = null, t();
      }
    }
    function J(e) {
      s.onAbort && s.onAbort(e), e = "Aborted(" + e + ")", G(e), Ue = !0, e += ". Build with -sASSERTIONS for more info.";
      var t = new WebAssembly.RuntimeError(e);
      throw Z(t), t;
    }
    var At = "data:application/octet-stream;base64,";
    function Be(e) {
      return e.startsWith(At);
    }
    var x;
    s.locateFile ? (x = "zxing_writer.wasm", Be(x) || (x = yt(x))) : x = new URL("/writer/zxing_writer.wasm", self.location).href;
    function Le(e) {
      try {
        if (e == x && K)
          return new Uint8Array(K);
        if (Pe)
          return Pe(e);
        throw "both async and sync fetching of the wasm failed";
      } catch (t) {
        J(t);
      }
    }
    function Rt(e) {
      return !K && (se || ue) && typeof fetch == "function" ? fetch(e, { credentials: "same-origin" }).then((t) => {
        if (!t.ok)
          throw "failed to load wasm binary file at '" + e + "'";
        return t.arrayBuffer();
      }).catch(() => Le(e)) : Promise.resolve().then(() => Le(e));
    }
    function Ne(e, t, r) {
      return Rt(e).then((n) => WebAssembly.instantiate(n, t)).then((n) => n).then(r, (n) => {
        G("failed to asynchronously prepare wasm: " + n), J(n);
      });
    }
    function Ft(e, t, r, n) {
      return !e && typeof WebAssembly.instantiateStreaming == "function" && !Be(t) && typeof fetch == "function" ? fetch(t, { credentials: "same-origin" }).then((i) => {
        var a = WebAssembly.instantiateStreaming(i, r);
        return a.then(n, function(u) {
          return G("wasm streaming compile failed: " + u), G("falling back to ArrayBuffer instantiation"), Ne(t, r, n);
        });
      }) : Ne(t, r, n);
    }
    function Et() {
      var e = { a: Yr };
      function t(n, i) {
        var a = n.exports;
        return s.asm = a, fe = s.asm.P, je(), He = s.asm.T, bt(s.asm.Q), Tt(), a;
      }
      Ct();
      function r(n) {
        t(n.instance);
      }
      if (s.instantiateWasm)
        try {
          return s.instantiateWasm(e, t);
        } catch (n) {
          G("Module.instantiateWasm callback failed with error: " + n), Z(n);
        }
      return Ft(K, x, e, r).catch(Z), {};
    }
    function Ce(e) {
      for (; e.length > 0; )
        e.shift()(s);
    }
    var le = [];
    function kt(e) {
      var t = new Te(e);
      return t.get_caught() || t.set_caught(!0), t.set_rethrown(!1), le.push(t), ct(t.excPtr), t.get_exception_ptr();
    }
    var k = 0;
    function St() {
      _(0);
      var e = le.pop();
      ft(e.excPtr), k = 0;
    }
    function Te(e) {
      this.excPtr = e, this.ptr = e - 24, this.set_type = function(t) {
        g[this.ptr + 4 >> 2] = t;
      }, this.get_type = function() {
        return g[this.ptr + 4 >> 2];
      }, this.set_destructor = function(t) {
        g[this.ptr + 8 >> 2] = t;
      }, this.get_destructor = function() {
        return g[this.ptr + 8 >> 2];
      }, this.set_caught = function(t) {
        t = t ? 1 : 0, I[this.ptr + 12 >> 0] = t;
      }, this.get_caught = function() {
        return I[this.ptr + 12 >> 0] != 0;
      }, this.set_rethrown = function(t) {
        t = t ? 1 : 0, I[this.ptr + 13 >> 0] = t;
      }, this.get_rethrown = function() {
        return I[this.ptr + 13 >> 0] != 0;
      }, this.init = function(t, r) {
        this.set_adjusted_ptr(0), this.set_type(t), this.set_destructor(r);
      }, this.set_adjusted_ptr = function(t) {
        g[this.ptr + 16 >> 2] = t;
      }, this.get_adjusted_ptr = function() {
        return g[this.ptr + 16 >> 2];
      }, this.get_exception_ptr = function() {
        var t = dt(this.get_type());
        if (t)
          return g[this.excPtr >> 2];
        var r = this.get_adjusted_ptr();
        return r !== 0 ? r : this.excPtr;
      };
    }
    function Ot(e) {
      throw k || (k = e), k;
    }
    function Ae() {
      var e = k;
      if (!e)
        return ie(0), 0;
      var t = new Te(e);
      t.set_adjusted_ptr(e);
      var r = t.get_type();
      if (!r)
        return ie(0), e;
      for (var n = 0; n < arguments.length; n++) {
        var i = arguments[n];
        if (i === 0 || i === r)
          break;
        var a = t.ptr + 16;
        if (lt(i, r, a))
          return ie(i), e;
      }
      return ie(r), e;
    }
    var Dt = Ae, Ut = Ae, Wt = Ae;
    function It() {
      var e = le.pop();
      e || J("no exception to throw");
      var t = e.excPtr;
      throw e.get_rethrown() || (le.push(e), e.set_rethrown(!0), e.set_caught(!1)), k = t, k;
    }
    function jt(e, t, r) {
      var n = new Te(e);
      throw n.init(t, r), k = e, k;
    }
    function Ht(e, t, r, n, i) {
    }
    function Re(e) {
      switch (e) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError(`Unknown type size: ${e}`);
      }
    }
    function xt() {
      for (var e = new Array(256), t = 0; t < 256; ++t)
        e[t] = String.fromCharCode(t);
      Ze = e;
    }
    var Ze = void 0;
    function T(e) {
      for (var t = "", r = e; C[r]; )
        t += Ze[C[r++]];
      return t;
    }
    var z = {}, M = {}, de = {}, Mt = 48, Vt = 57;
    function Xe(e) {
      if (e === void 0)
        return "_unknown";
      e = e.replace(/[^a-zA-Z0-9_]/g, "$");
      var t = e.charCodeAt(0);
      return t >= Mt && t <= Vt ? `_${e}` : e;
    }
    function ze(e, t) {
      return e = Xe(e), { [e]: function() {
        return t.apply(this, arguments);
      } }[e];
    }
    function Fe(e, t) {
      var r = ze(t, function(n) {
        this.name = t, this.message = n;
        var i = new Error(n).stack;
        i !== void 0 && (this.stack = this.toString() + `
` + i.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return r.prototype = Object.create(e.prototype), r.prototype.constructor = r, r.prototype.toString = function() {
        return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
      }, r;
    }
    var Y = void 0;
    function d(e) {
      throw new Y(e);
    }
    var qe = void 0;
    function pe(e) {
      throw new qe(e);
    }
    function he(e, t, r) {
      e.forEach(function(o) {
        de[o] = t;
      });
      function n(o) {
        var f = r(o);
        f.length !== e.length && pe("Mismatched type converter count");
        for (var c = 0; c < e.length; ++c)
          S(e[c], f[c]);
      }
      var i = new Array(t.length), a = [], u = 0;
      t.forEach((o, f) => {
        M.hasOwnProperty(o) ? i[f] = M[o] : (a.push(o), z.hasOwnProperty(o) || (z[o] = []), z[o].push(() => {
          i[f] = M[o], ++u, u === a.length && n(i);
        }));
      }), a.length === 0 && n(i);
    }
    function S(e, t, r = {}) {
      if (!("argPackAdvance" in t))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      var n = t.name;
      if (e || d(`type "${n}" must have a positive integer typeid pointer`), M.hasOwnProperty(e)) {
        if (r.ignoreDuplicateRegistrations)
          return;
        d(`Cannot register type '${n}' twice`);
      }
      if (M[e] = t, delete de[e], z.hasOwnProperty(e)) {
        var i = z[e];
        delete z[e], i.forEach((a) => a());
      }
    }
    function Bt(e, t, r, n, i) {
      var a = Re(r);
      t = T(t), S(e, { name: t, fromWireType: function(u) {
        return !!u;
      }, toWireType: function(u, o) {
        return o ? n : i;
      }, argPackAdvance: 8, readValueFromPointer: function(u) {
        var o;
        if (r === 1)
          o = I;
        else if (r === 2)
          o = X;
        else if (r === 4)
          o = j;
        else
          throw new TypeError("Unknown boolean type size: " + t);
        return this.fromWireType(o[u >> a]);
      }, destructorFunction: null });
    }
    function Lt(e) {
      if (!(this instanceof U) || !(e instanceof U))
        return !1;
      for (var t = this.$$.ptrType.registeredClass, r = this.$$.ptr, n = e.$$.ptrType.registeredClass, i = e.$$.ptr; t.baseClass; )
        r = t.upcast(r), t = t.baseClass;
      for (; n.baseClass; )
        i = n.upcast(i), n = n.baseClass;
      return t === n && r === i;
    }
    function Nt(e) {
      return { count: e.count, deleteScheduled: e.deleteScheduled, preservePointerOnDelete: e.preservePointerOnDelete, ptr: e.ptr, ptrType: e.ptrType, smartPtr: e.smartPtr, smartPtrType: e.smartPtrType };
    }
    function Ee(e) {
      function t(r) {
        return r.$$.ptrType.registeredClass.name;
      }
      d(t(e) + " instance already deleted");
    }
    var ke = !1;
    function Ge(e) {
    }
    function Zt(e) {
      e.smartPtr ? e.smartPtrType.rawDestructor(e.smartPtr) : e.ptrType.registeredClass.rawDestructor(e.ptr);
    }
    function Ke(e) {
      e.count.value -= 1;
      var t = e.count.value === 0;
      t && Zt(e);
    }
    function Qe(e, t, r) {
      if (t === r)
        return e;
      if (r.baseClass === void 0)
        return null;
      var n = Qe(e, t, r.baseClass);
      return n === null ? null : r.downcast(n);
    }
    var Je = {};
    function Xt() {
      return Object.keys(re).length;
    }
    function zt() {
      var e = [];
      for (var t in re)
        re.hasOwnProperty(t) && e.push(re[t]);
      return e;
    }
    var ee = [];
    function Se() {
      for (; ee.length; ) {
        var e = ee.pop();
        e.$$.deleteScheduled = !1, e.delete();
      }
    }
    var te = void 0;
    function qt(e) {
      te = e, ee.length && te && te(Se);
    }
    function Gt() {
      s.getInheritedInstanceCount = Xt, s.getLiveInheritedInstances = zt, s.flushPendingDeletes = Se, s.setDelayFunction = qt;
    }
    var re = {};
    function Kt(e, t) {
      for (t === void 0 && d("ptr should not be undefined"); e.baseClass; )
        t = e.upcast(t), e = e.baseClass;
      return t;
    }
    function Qt(e, t) {
      return t = Kt(e, t), re[t];
    }
    function ve(e, t) {
      (!t.ptrType || !t.ptr) && pe("makeClassHandle requires ptr and ptrType");
      var r = !!t.smartPtrType, n = !!t.smartPtr;
      return r !== n && pe("Both smartPtrType and smartPtr must be specified"), t.count = { value: 1 }, ne(Object.create(e, { $$: { value: t } }));
    }
    function Jt(e) {
      var t = this.getPointee(e);
      if (!t)
        return this.destructor(e), null;
      var r = Qt(this.registeredClass, t);
      if (r !== void 0) {
        if (r.$$.count.value === 0)
          return r.$$.ptr = t, r.$$.smartPtr = e, r.clone();
        var n = r.clone();
        return this.destructor(e), n;
      }
      function i() {
        return this.isSmartPointer ? ve(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: t, smartPtrType: this, smartPtr: e }) : ve(this.registeredClass.instancePrototype, { ptrType: this, ptr: e });
      }
      var a = this.registeredClass.getActualType(t), u = Je[a];
      if (!u)
        return i.call(this);
      var o;
      this.isConst ? o = u.constPointerType : o = u.pointerType;
      var f = Qe(t, this.registeredClass, o.registeredClass);
      return f === null ? i.call(this) : this.isSmartPointer ? ve(o.registeredClass.instancePrototype, { ptrType: o, ptr: f, smartPtrType: this, smartPtr: e }) : ve(o.registeredClass.instancePrototype, { ptrType: o, ptr: f });
    }
    function ne(e) {
      return typeof FinalizationRegistry > "u" ? (ne = (t) => t, e) : (ke = new FinalizationRegistry((t) => {
        Ke(t.$$);
      }), ne = (t) => {
        var r = t.$$, n = !!r.smartPtr;
        if (n) {
          var i = { $$: r };
          ke.register(t, i, t);
        }
        return t;
      }, Ge = (t) => ke.unregister(t), ne(e));
    }
    function Yt() {
      if (this.$$.ptr || Ee(this), this.$$.preservePointerOnDelete)
        return this.$$.count.value += 1, this;
      var e = ne(Object.create(Object.getPrototypeOf(this), { $$: { value: Nt(this.$$) } }));
      return e.$$.count.value += 1, e.$$.deleteScheduled = !1, e;
    }
    function er() {
      this.$$.ptr || Ee(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && d("Object already scheduled for deletion"), Ge(this), Ke(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
    }
    function tr() {
      return !this.$$.ptr;
    }
    function rr() {
      return this.$$.ptr || Ee(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && d("Object already scheduled for deletion"), ee.push(this), ee.length === 1 && te && te(Se), this.$$.deleteScheduled = !0, this;
    }
    function nr() {
      U.prototype.isAliasOf = Lt, U.prototype.clone = Yt, U.prototype.delete = er, U.prototype.isDeleted = tr, U.prototype.deleteLater = rr;
    }
    function U() {
    }
    function ir(e, t, r) {
      if (e[t].overloadTable === void 0) {
        var n = e[t];
        e[t] = function() {
          return e[t].overloadTable.hasOwnProperty(arguments.length) || d(`Function '${r}' called with an invalid number of arguments (${arguments.length}) - expects one of (${e[t].overloadTable})!`), e[t].overloadTable[arguments.length].apply(this, arguments);
        }, e[t].overloadTable = [], e[t].overloadTable[n.argCount] = n;
      }
    }
    function Ye(e, t, r) {
      s.hasOwnProperty(e) ? ((r === void 0 || s[e].overloadTable !== void 0 && s[e].overloadTable[r] !== void 0) && d(`Cannot register public name '${e}' twice`), ir(s, e, e), s.hasOwnProperty(r) && d(`Cannot register multiple overloads of a function with the same number of arguments (${r})!`), s[e].overloadTable[r] = t) : (s[e] = t, r !== void 0 && (s[e].numArguments = r));
    }
    function ar(e, t, r, n, i, a, u, o) {
      this.name = e, this.constructor = t, this.instancePrototype = r, this.rawDestructor = n, this.baseClass = i, this.getActualType = a, this.upcast = u, this.downcast = o, this.pureVirtualFunctions = [];
    }
    function ge(e, t, r) {
      for (; t !== r; )
        t.upcast || d(`Expected null or instance of ${r.name}, got an instance of ${t.name}`), e = t.upcast(e), t = t.baseClass;
      return e;
    }
    function or(e, t) {
      if (t === null)
        return this.isReference && d(`null is not a valid ${this.name}`), 0;
      t.$$ || d(`Cannot pass "${Oe(t)}" as a ${this.name}`), t.$$.ptr || d(`Cannot pass deleted object as a pointer of type ${this.name}`);
      var r = t.$$.ptrType.registeredClass, n = ge(t.$$.ptr, r, this.registeredClass);
      return n;
    }
    function sr(e, t) {
      var r;
      if (t === null)
        return this.isReference && d(`null is not a valid ${this.name}`), this.isSmartPointer ? (r = this.rawConstructor(), e !== null && e.push(this.rawDestructor, r), r) : 0;
      t.$$ || d(`Cannot pass "${Oe(t)}" as a ${this.name}`), t.$$.ptr || d(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && t.$$.ptrType.isConst && d(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);
      var n = t.$$.ptrType.registeredClass;
      if (r = ge(t.$$.ptr, n, this.registeredClass), this.isSmartPointer)
        switch (t.$$.smartPtr === void 0 && d("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
          case 0:
            t.$$.smartPtrType === this ? r = t.$$.smartPtr : d(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);
            break;
          case 1:
            r = t.$$.smartPtr;
            break;
          case 2:
            if (t.$$.smartPtrType === this)
              r = t.$$.smartPtr;
            else {
              var i = t.clone();
              r = this.rawShare(r, $e.toHandle(function() {
                i.delete();
              })), e !== null && e.push(this.rawDestructor, r);
            }
            break;
          default:
            d("Unsupporting sharing policy");
        }
      return r;
    }
    function ur(e, t) {
      if (t === null)
        return this.isReference && d(`null is not a valid ${this.name}`), 0;
      t.$$ || d(`Cannot pass "${Oe(t)}" as a ${this.name}`), t.$$.ptr || d(`Cannot pass deleted object as a pointer of type ${this.name}`), t.$$.ptrType.isConst && d(`Cannot convert argument of type ${t.$$.ptrType.name} to parameter type ${this.name}`);
      var r = t.$$.ptrType.registeredClass, n = ge(t.$$.ptr, r, this.registeredClass);
      return n;
    }
    function ye(e) {
      return this.fromWireType(j[e >> 2]);
    }
    function fr(e) {
      return this.rawGetPointee && (e = this.rawGetPointee(e)), e;
    }
    function cr(e) {
      this.rawDestructor && this.rawDestructor(e);
    }
    function lr(e) {
      e !== null && e.delete();
    }
    function dr() {
      O.prototype.getPointee = fr, O.prototype.destructor = cr, O.prototype.argPackAdvance = 8, O.prototype.readValueFromPointer = ye, O.prototype.deleteObject = lr, O.prototype.fromWireType = Jt;
    }
    function O(e, t, r, n, i, a, u, o, f, c, l) {
      this.name = e, this.registeredClass = t, this.isReference = r, this.isConst = n, this.isSmartPointer = i, this.pointeeType = a, this.sharingPolicy = u, this.rawGetPointee = o, this.rawConstructor = f, this.rawShare = c, this.rawDestructor = l, !i && t.baseClass === void 0 ? n ? (this.toWireType = or, this.destructorFunction = null) : (this.toWireType = ur, this.destructorFunction = null) : this.toWireType = sr;
    }
    function et(e, t, r) {
      s.hasOwnProperty(e) || pe("Replacing nonexistant public symbol"), s[e].overloadTable !== void 0 && r !== void 0 ? s[e].overloadTable[r] = t : (s[e] = t, s[e].argCount = r);
    }
    function pr(e, t, r) {
      var n = s["dynCall_" + e];
      return r && r.length ? n.apply(null, [t].concat(r)) : n.call(null, t);
    }
    var _e = [];
    function y(e) {
      var t = _e[e];
      return t || (e >= _e.length && (_e.length = e + 1), _e[e] = t = He.get(e)), t;
    }
    function hr(e, t, r) {
      if (e.includes("j"))
        return pr(e, t, r);
      var n = y(t).apply(null, r);
      return n;
    }
    function vr(e, t) {
      var r = [];
      return function() {
        return r.length = 0, Object.assign(r, arguments), hr(e, t, r);
      };
    }
    function V(e, t) {
      e = T(e);
      function r() {
        return e.includes("j") ? vr(e, t) : y(t);
      }
      var n = r();
      return typeof n != "function" && d(`unknown function pointer with signature ${e}: ${t}`), n;
    }
    var tt = void 0;
    function rt(e) {
      var t = ut(e), r = T(t);
      return D(t), r;
    }
    function me(e, t) {
      var r = [], n = {};
      function i(a) {
        if (!n[a] && !M[a]) {
          if (de[a]) {
            de[a].forEach(i);
            return;
          }
          r.push(a), n[a] = !0;
        }
      }
      throw t.forEach(i), new tt(`${e}: ` + r.map(rt).join([", "]));
    }
    function gr(e, t, r, n, i, a, u, o, f, c, l, p, h) {
      l = T(l), a = V(i, a), o && (o = V(u, o)), c && (c = V(f, c)), h = V(p, h);
      var v = Xe(l);
      Ye(v, function() {
        me(`Cannot construct ${l} due to unbound types`, [n]);
      }), he([e, t, r], n ? [n] : [], function(P) {
        P = P[0];
        var R, b;
        n ? (R = P.registeredClass, b = R.instancePrototype) : b = U.prototype;
        var E = ze(v, function() {
          if (Object.getPrototypeOf(this) !== B)
            throw new Y("Use 'new' to construct " + l);
          if (m.constructor_body === void 0)
            throw new Y(l + " has no accessible constructor");
          var vt = m.constructor_body[arguments.length];
          if (vt === void 0)
            throw new Y(`Tried to invoke ctor of ${l} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(m.constructor_body).toString()}) parameters instead!`);
          return vt.apply(this, arguments);
        }), B = Object.create(b, { constructor: { value: E } });
        E.prototype = B;
        var m = new ar(l, E, B, h, R, a, o, c);
        m.baseClass && (m.baseClass.__derivedClasses === void 0 && (m.baseClass.__derivedClasses = []), m.baseClass.__derivedClasses.push(m));
        var W = new O(l, m, !0, !1, !1), be = new O(l + "*", m, !1, !1, !1), ht = new O(l + " const*", m, !1, !0, !1);
        return Je[e] = { pointerType: be, constPointerType: ht }, et(v, E), [W, be, ht];
      });
    }
    function nt(e) {
      for (; e.length; ) {
        var t = e.pop(), r = e.pop();
        r(t);
      }
    }
    function it(e, t, r) {
      return e instanceof Object || d(`${r} with invalid "this": ${e}`), e instanceof t.registeredClass.constructor || d(`${r} incompatible with "this" of type ${e.constructor.name}`), e.$$.ptr || d(`cannot call emscripten binding method ${r} on deleted object`), ge(e.$$.ptr, e.$$.ptrType.registeredClass, t.registeredClass);
    }
    function yr(e, t, r, n, i, a, u, o, f, c) {
      t = T(t), i = V(n, i), he([], [e], function(l) {
        l = l[0];
        var p = `${l.name}.${t}`, h = { get: function() {
          me(`Cannot access ${p} due to unbound types`, [r, u]);
        }, enumerable: !0, configurable: !0 };
        return f ? h.set = () => {
          me(`Cannot access ${p} due to unbound types`, [r, u]);
        } : h.set = (v) => {
          d(p + " is a read-only property");
        }, Object.defineProperty(l.registeredClass.instancePrototype, t, h), he([], f ? [r, u] : [r], function(v) {
          var P = v[0], R = { get: function() {
            var E = it(this, l, p + " getter");
            return P.fromWireType(i(a, E));
          }, enumerable: !0 };
          if (f) {
            f = V(o, f);
            var b = v[1];
            R.set = function(E) {
              var B = it(this, l, p + " setter"), m = [];
              f(c, B, b.toWireType(m, E)), nt(m);
            };
          }
          return Object.defineProperty(l.registeredClass.instancePrototype, t, R), [];
        }), [];
      });
    }
    function _r() {
      this.allocated = [void 0], this.freelist = [], this.get = function(e) {
        return this.allocated[e];
      }, this.has = function(e) {
        return this.allocated[e] !== void 0;
      }, this.allocate = function(e) {
        var t = this.freelist.pop() || this.allocated.length;
        return this.allocated[t] = e, t;
      }, this.free = function(e) {
        this.allocated[e] = void 0, this.freelist.push(e);
      };
    }
    var A = new _r();
    function at(e) {
      e >= A.reserved && --A.get(e).refcount === 0 && A.free(e);
    }
    function mr() {
      for (var e = 0, t = A.reserved; t < A.allocated.length; ++t)
        A.allocated[t] !== void 0 && ++e;
      return e;
    }
    function $r() {
      A.allocated.push({ value: void 0 }, { value: null }, { value: !0 }, { value: !1 }), A.reserved = A.allocated.length, s.count_emval_handles = mr;
    }
    var $e = { toValue: (e) => (e || d("Cannot use deleted val. handle = " + e), A.get(e).value), toHandle: (e) => {
      switch (e) {
        case void 0:
          return 1;
        case null:
          return 2;
        case !0:
          return 3;
        case !1:
          return 4;
        default:
          return A.allocate({ refcount: 1, value: e });
      }
    } };
    function wr(e, t) {
      t = T(t), S(e, { name: t, fromWireType: function(r) {
        var n = $e.toValue(r);
        return at(r), n;
      }, toWireType: function(r, n) {
        return $e.toHandle(n);
      }, argPackAdvance: 8, readValueFromPointer: ye, destructorFunction: null });
    }
    function Oe(e) {
      if (e === null)
        return "null";
      var t = typeof e;
      return t === "object" || t === "array" || t === "function" ? e.toString() : "" + e;
    }
    function br(e, t) {
      switch (t) {
        case 2:
          return function(r) {
            return this.fromWireType(We[r >> 2]);
          };
        case 3:
          return function(r) {
            return this.fromWireType(Ie[r >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + e);
      }
    }
    function Pr(e, t, r) {
      var n = Re(r);
      t = T(t), S(e, { name: t, fromWireType: function(i) {
        return i;
      }, toWireType: function(i, a) {
        return a;
      }, argPackAdvance: 8, readValueFromPointer: br(t, n), destructorFunction: null });
    }
    function Cr(e, t, r, n, i, a) {
      var u = t.length;
      u < 2 && d("argTypes array size mismatch! Must at least get return value and 'this' types!");
      for (var o = t[1] !== null && r !== null, f = !1, c = 1; c < t.length; ++c)
        if (t[c] !== null && t[c].destructorFunction === void 0) {
          f = !0;
          break;
        }
      var l = t[0].name !== "void", p = u - 2, h = new Array(p), v = [], P = [];
      return function() {
        arguments.length !== p && d(`function ${e} called with ${arguments.length} arguments, expected ${p} args!`), P.length = 0;
        var R;
        v.length = o ? 2 : 1, v[0] = i, o && (R = t[1].toWireType(P, this), v[1] = R);
        for (var b = 0; b < p; ++b)
          h[b] = t[b + 2].toWireType(P, arguments[b]), v.push(h[b]);
        var E = n.apply(null, v);
        function B(m) {
          if (f)
            nt(P);
          else
            for (var W = o ? 1 : 2; W < t.length; W++) {
              var be = W === 1 ? R : h[W - 2];
              t[W].destructorFunction !== null && t[W].destructorFunction(be);
            }
          if (l)
            return t[0].fromWireType(m);
        }
        return B(E);
      };
    }
    function Tr(e, t) {
      for (var r = [], n = 0; n < e; n++)
        r.push(g[t + n * 4 >> 2]);
      return r;
    }
    function Ar(e, t, r, n, i, a, u) {
      var o = Tr(t, r);
      e = T(e), i = V(n, i), Ye(e, function() {
        me(`Cannot call ${e} due to unbound types`, o);
      }, t - 1), he([], o, function(f) {
        var c = [f[0], null].concat(f.slice(1));
        return et(e, Cr(e, c, null, i, a), t - 1), [];
      });
    }
    function Rr(e, t, r) {
      switch (t) {
        case 0:
          return r ? function(i) {
            return I[i];
          } : function(i) {
            return C[i];
          };
        case 1:
          return r ? function(i) {
            return X[i >> 1];
          } : function(i) {
            return ce[i >> 1];
          };
        case 2:
          return r ? function(i) {
            return j[i >> 2];
          } : function(i) {
            return g[i >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + e);
      }
    }
    function Fr(e, t, r, n, i) {
      t = T(t);
      var a = Re(r), u = (p) => p;
      if (n === 0) {
        var o = 32 - 8 * r;
        u = (p) => p << o >>> o;
      }
      var f = t.includes("unsigned"), c = (p, h) => {
      }, l;
      f ? l = function(p, h) {
        return c(h, this.name), h >>> 0;
      } : l = function(p, h) {
        return c(h, this.name), h;
      }, S(e, { name: t, fromWireType: u, toWireType: l, argPackAdvance: 8, readValueFromPointer: Rr(t, a, n !== 0), destructorFunction: null });
    }
    function Er(e, t, r) {
      var n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], i = n[t];
      function a(u) {
        u = u >> 2;
        var o = g, f = o[u], c = o[u + 1];
        return new i(o.buffer, c, f);
      }
      r = T(r), S(e, { name: r, fromWireType: a, argPackAdvance: 8, readValueFromPointer: a }, { ignoreDuplicateRegistrations: !0 });
    }
    function kr(e, t, r, n) {
      if (!(n > 0))
        return 0;
      for (var i = r, a = r + n - 1, u = 0; u < e.length; ++u) {
        var o = e.charCodeAt(u);
        if (o >= 55296 && o <= 57343) {
          var f = e.charCodeAt(++u);
          o = 65536 + ((o & 1023) << 10) | f & 1023;
        }
        if (o <= 127) {
          if (r >= a)
            break;
          t[r++] = o;
        } else if (o <= 2047) {
          if (r + 1 >= a)
            break;
          t[r++] = 192 | o >> 6, t[r++] = 128 | o & 63;
        } else if (o <= 65535) {
          if (r + 2 >= a)
            break;
          t[r++] = 224 | o >> 12, t[r++] = 128 | o >> 6 & 63, t[r++] = 128 | o & 63;
        } else {
          if (r + 3 >= a)
            break;
          t[r++] = 240 | o >> 18, t[r++] = 128 | o >> 12 & 63, t[r++] = 128 | o >> 6 & 63, t[r++] = 128 | o & 63;
        }
      }
      return t[r] = 0, r - i;
    }
    function Sr(e, t, r) {
      return kr(e, C, t, r);
    }
    function Or(e) {
      for (var t = 0, r = 0; r < e.length; ++r) {
        var n = e.charCodeAt(r);
        n <= 127 ? t++ : n <= 2047 ? t += 2 : n >= 55296 && n <= 57343 ? (t += 4, ++r) : t += 3;
      }
      return t;
    }
    var ot = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
    function Dr(e, t, r) {
      for (var n = t + r, i = t; e[i] && !(i >= n); )
        ++i;
      if (i - t > 16 && e.buffer && ot)
        return ot.decode(e.subarray(t, i));
      for (var a = ""; t < i; ) {
        var u = e[t++];
        if (!(u & 128)) {
          a += String.fromCharCode(u);
          continue;
        }
        var o = e[t++] & 63;
        if ((u & 224) == 192) {
          a += String.fromCharCode((u & 31) << 6 | o);
          continue;
        }
        var f = e[t++] & 63;
        if ((u & 240) == 224 ? u = (u & 15) << 12 | o << 6 | f : u = (u & 7) << 18 | o << 12 | f << 6 | e[t++] & 63, u < 65536)
          a += String.fromCharCode(u);
        else {
          var c = u - 65536;
          a += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
        }
      }
      return a;
    }
    function Ur(e, t) {
      return e ? Dr(C, e, t) : "";
    }
    function Wr(e, t) {
      t = T(t);
      var r = t === "std::string";
      S(e, { name: t, fromWireType: function(n) {
        var i = g[n >> 2], a = n + 4, u;
        if (r)
          for (var o = a, f = 0; f <= i; ++f) {
            var c = a + f;
            if (f == i || C[c] == 0) {
              var l = c - o, p = Ur(o, l);
              u === void 0 ? u = p : (u += String.fromCharCode(0), u += p), o = c + 1;
            }
          }
        else {
          for (var h = new Array(i), f = 0; f < i; ++f)
            h[f] = String.fromCharCode(C[a + f]);
          u = h.join("");
        }
        return D(n), u;
      }, toWireType: function(n, i) {
        i instanceof ArrayBuffer && (i = new Uint8Array(i));
        var a, u = typeof i == "string";
        u || i instanceof Uint8Array || i instanceof Uint8ClampedArray || i instanceof Int8Array || d("Cannot pass non-string to std::string"), r && u ? a = Or(i) : a = i.length;
        var o = De(4 + a + 1), f = o + 4;
        if (g[o >> 2] = a, r && u)
          Sr(i, f, a + 1);
        else if (u)
          for (var c = 0; c < a; ++c) {
            var l = i.charCodeAt(c);
            l > 255 && (D(f), d("String has UTF-16 code units that do not fit in 8 bits")), C[f + c] = l;
          }
        else
          for (var c = 0; c < a; ++c)
            C[f + c] = i[c];
        return n !== null && n.push(D, o), o;
      }, argPackAdvance: 8, readValueFromPointer: ye, destructorFunction: function(n) {
        D(n);
      } });
    }
    var st = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0;
    function Ir(e, t) {
      for (var r = e, n = r >> 1, i = n + t / 2; !(n >= i) && ce[n]; )
        ++n;
      if (r = n << 1, r - e > 32 && st)
        return st.decode(C.subarray(e, r));
      for (var a = "", u = 0; !(u >= t / 2); ++u) {
        var o = X[e + u * 2 >> 1];
        if (o == 0)
          break;
        a += String.fromCharCode(o);
      }
      return a;
    }
    function jr(e, t, r) {
      if (r === void 0 && (r = 2147483647), r < 2)
        return 0;
      r -= 2;
      for (var n = t, i = r < e.length * 2 ? r / 2 : e.length, a = 0; a < i; ++a) {
        var u = e.charCodeAt(a);
        X[t >> 1] = u, t += 2;
      }
      return X[t >> 1] = 0, t - n;
    }
    function Hr(e) {
      return e.length * 2;
    }
    function xr(e, t) {
      for (var r = 0, n = ""; !(r >= t / 4); ) {
        var i = j[e + r * 4 >> 2];
        if (i == 0)
          break;
        if (++r, i >= 65536) {
          var a = i - 65536;
          n += String.fromCharCode(55296 | a >> 10, 56320 | a & 1023);
        } else
          n += String.fromCharCode(i);
      }
      return n;
    }
    function Mr(e, t, r) {
      if (r === void 0 && (r = 2147483647), r < 4)
        return 0;
      for (var n = t, i = n + r - 4, a = 0; a < e.length; ++a) {
        var u = e.charCodeAt(a);
        if (u >= 55296 && u <= 57343) {
          var o = e.charCodeAt(++a);
          u = 65536 + ((u & 1023) << 10) | o & 1023;
        }
        if (j[t >> 2] = u, t += 4, t + 4 > i)
          break;
      }
      return j[t >> 2] = 0, t - n;
    }
    function Vr(e) {
      for (var t = 0, r = 0; r < e.length; ++r) {
        var n = e.charCodeAt(r);
        n >= 55296 && n <= 57343 && ++r, t += 4;
      }
      return t;
    }
    function Br(e, t, r) {
      r = T(r);
      var n, i, a, u, o;
      t === 2 ? (n = Ir, i = jr, u = Hr, a = () => ce, o = 1) : t === 4 && (n = xr, i = Mr, u = Vr, a = () => g, o = 2), S(e, { name: r, fromWireType: function(f) {
        for (var c = g[f >> 2], l = a(), p, h = f + 4, v = 0; v <= c; ++v) {
          var P = f + 4 + v * t;
          if (v == c || l[P >> o] == 0) {
            var R = P - h, b = n(h, R);
            p === void 0 ? p = b : (p += String.fromCharCode(0), p += b), h = P + t;
          }
        }
        return D(f), p;
      }, toWireType: function(f, c) {
        typeof c != "string" && d(`Cannot pass non-string to C++ string type ${r}`);
        var l = u(c), p = De(4 + l + t);
        return g[p >> 2] = l >> o, i(c, p + 4, l + t), f !== null && f.push(D, p), p;
      }, argPackAdvance: 8, readValueFromPointer: ye, destructorFunction: function(f) {
        D(f);
      } });
    }
    function Lr(e, t) {
      t = T(t), S(e, { isVoid: !0, name: t, argPackAdvance: 0, fromWireType: function() {
      }, toWireType: function(r, n) {
      } });
    }
    function Nr(e) {
      e > 4 && (A.get(e).refcount += 1);
    }
    function Zr(e, t) {
      var r = M[e];
      return r === void 0 && d(t + " has unknown type " + rt(e)), r;
    }
    function Xr(e, t) {
      e = Zr(e, "_emval_take_value");
      var r = e.readValueFromPointer(t);
      return $e.toHandle(r);
    }
    function zr() {
      J("");
    }
    function qr(e, t, r) {
      C.copyWithin(e, t, t + r);
    }
    function Gr() {
      return 2147483648;
    }
    function Kr(e) {
      var t = fe.buffer, r = e - t.byteLength + 65535 >>> 16;
      try {
        return fe.grow(r), je(), 1;
      } catch {
      }
    }
    function Qr(e) {
      var t = C.length;
      e = e >>> 0;
      var r = Gr();
      if (e > r)
        return !1;
      for (var n = (f, c) => f + (c - f % c) % c, i = 1; i <= 4; i *= 2) {
        var a = t * (1 + 0.2 / i);
        a = Math.min(a, e + 100663296);
        var u = Math.min(r, n(Math.max(e, a), 65536)), o = Kr(u);
        if (o)
          return !0;
      }
      return !1;
    }
    function Jr(e) {
      return e;
    }
    xt(), Y = s.BindingError = Fe(Error, "BindingError"), qe = s.InternalError = Fe(Error, "InternalError"), nr(), Gt(), dr(), tt = s.UnboundTypeError = Fe(Error, "UnboundTypeError"), $r();
    var Yr = { t: kt, u: St, a: Dt, n: Ut, s: Wt, I: It, l: jt, f: Ot, B: Ht, F: Bt, O: gr, z: yr, E: wr, y: Pr, N: Ar, q: Fr, p: Er, x: Wr, v: Br, G: Lr, K: at, L: Nr, M: Xr, w: zr, D: qr, C: Qr, r: pn, b: en, c: an, i: cn, j: hn, h: ln, H: dn, k: on, e: sn, g: fn, d: tn, o: nn, m: rn, J: un, A: Jr };
    Et();
    var De = s._malloc = function() {
      return (De = s._malloc = s.asm.R).apply(null, arguments);
    }, D = s._free = function() {
      return (D = s._free = s.asm.S).apply(null, arguments);
    }, ut = function() {
      return (ut = s.asm.U).apply(null, arguments);
    };
    s.__embind_initialize_bindings = function() {
      return (s.__embind_initialize_bindings = s.asm.V).apply(null, arguments);
    };
    var _ = function() {
      return (_ = s.asm.W).apply(null, arguments);
    }, ie = function() {
      return (ie = s.asm.X).apply(null, arguments);
    }, $ = function() {
      return ($ = s.asm.Y).apply(null, arguments);
    }, w = function() {
      return (w = s.asm.Z).apply(null, arguments);
    }, ft = function() {
      return (ft = s.asm._).apply(null, arguments);
    }, ct = function() {
      return (ct = s.asm.$).apply(null, arguments);
    }, lt = function() {
      return (lt = s.asm.aa).apply(null, arguments);
    }, dt = function() {
      return (dt = s.asm.ba).apply(null, arguments);
    };
    function en(e, t) {
      var r = $();
      try {
        return y(e)(t);
      } catch (n) {
        if (w(r), n !== n + 0)
          throw n;
        _(1, 0);
      }
    }
    function tn(e, t, r, n) {
      var i = $();
      try {
        y(e)(t, r, n);
      } catch (a) {
        if (w(i), a !== a + 0)
          throw a;
        _(1, 0);
      }
    }
    function rn(e, t, r, n, i, a) {
      var u = $();
      try {
        y(e)(t, r, n, i, a);
      } catch (o) {
        if (w(u), o !== o + 0)
          throw o;
        _(1, 0);
      }
    }
    function nn(e, t, r, n, i) {
      var a = $();
      try {
        y(e)(t, r, n, i);
      } catch (u) {
        if (w(a), u !== u + 0)
          throw u;
        _(1, 0);
      }
    }
    function an(e, t, r) {
      var n = $();
      try {
        return y(e)(t, r);
      } catch (i) {
        if (w(n), i !== i + 0)
          throw i;
        _(1, 0);
      }
    }
    function on(e) {
      var t = $();
      try {
        y(e)();
      } catch (r) {
        if (w(t), r !== r + 0)
          throw r;
        _(1, 0);
      }
    }
    function sn(e, t) {
      var r = $();
      try {
        y(e)(t);
      } catch (n) {
        if (w(r), n !== n + 0)
          throw n;
        _(1, 0);
      }
    }
    function un(e, t, r, n, i, a, u, o, f) {
      var c = $();
      try {
        y(e)(t, r, n, i, a, u, o, f);
      } catch (l) {
        if (w(c), l !== l + 0)
          throw l;
        _(1, 0);
      }
    }
    function fn(e, t, r) {
      var n = $();
      try {
        y(e)(t, r);
      } catch (i) {
        if (w(n), i !== i + 0)
          throw i;
        _(1, 0);
      }
    }
    function cn(e, t, r, n) {
      var i = $();
      try {
        return y(e)(t, r, n);
      } catch (a) {
        if (w(i), a !== a + 0)
          throw a;
        _(1, 0);
      }
    }
    function ln(e, t, r, n, i, a) {
      var u = $();
      try {
        return y(e)(t, r, n, i, a);
      } catch (o) {
        if (w(u), o !== o + 0)
          throw o;
        _(1, 0);
      }
    }
    function dn(e, t, r, n, i, a, u) {
      var o = $();
      try {
        return y(e)(t, r, n, i, a, u);
      } catch (f) {
        if (w(o), f !== f + 0)
          throw f;
        _(1, 0);
      }
    }
    function pn(e) {
      var t = $();
      try {
        return y(e)();
      } catch (r) {
        if (w(t), r !== r + 0)
          throw r;
        _(1, 0);
      }
    }
    function hn(e, t, r, n, i) {
      var a = $();
      try {
        return y(e)(t, r, n, i);
      } catch (u) {
        if (w(a), u !== u + 0)
          throw u;
        _(1, 0);
      }
    }
    var we;
    Q = function e() {
      we || pt(), we || (Q = e);
    };
    function pt() {
      if (H > 0 || (_t(), H > 0))
        return;
      function e() {
        we || (we = !0, s.calledRun = !0, !Ue && (mt(), ae(s), s.onRuntimeInitialized && s.onRuntimeInitialized(), $t()));
      }
      s.setStatus ? (s.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          s.setStatus("");
        }, 1), e();
      }, 1)) : e();
    }
    if (s.preInit)
      for (typeof s.preInit == "function" && (s.preInit = [s.preInit]); s.preInit.length > 0; )
        s.preInit.pop()();
    return pt(), q.ready;
  };
})();
function _n(N) {
  return vn(gt, N);
}
async function mn(N, {
  format: q = L.format,
  charset: s = L.charset,
  quietZone: ae = L.quietZone,
  width: Z = L.width,
  height: oe = L.height,
  eccLevel: se = L.eccLevel
} = L) {
  return gn(
    N,
    {
      format: q,
      charset: s,
      quietZone: ae,
      width: Z,
      height: oe,
      eccLevel: se
    },
    gt
  );
}
export {
  bn as ZXING_BARCODE_FORMAT_NAMES,
  Pn as ZXING_CHARACTOR_SET_NAMES,
  Cn as defaultZXingReadOptions,
  L as defaultZXingWriteOptions,
  _n as getZXingModule,
  Tn as purgeZXingModule,
  An as setZXingModuleOverrides,
  mn as writeBarcodeToImageFile
};
